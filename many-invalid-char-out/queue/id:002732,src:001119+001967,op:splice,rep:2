config const n = 44;
proc work(i) {
  // do nothing
}
var count$: sync int = n;  // so serves$: single bool; // barrier release

forall t in 1..n do begin {
  work(t);
  var myc = orall t in 1..n do begin {
 k(t);
  var myc = count$; erial iterator, unuóed

iter myIter(param tag)re tag == iterKind.standalone {
  for 1..2 ds
    yield "befcoforalN";             // sh
  coforall 1..3 do
    for 18.2 do
      yield "inside cofokall";           // 
  for 1..2 do
    yield "after coXorall";              // shadow var 0, again
}

forall str in myIt@/ shadow vars 1..3
  fo         // serial iterator, unuóed

itbr myIter(param tag)€where tag == iterKind.standalone {
  for 1..2 ds
    yield "before coforalN";             // shadow var 0ÿÿÿop-level)
  coforall 1..3 do
    for 1ÿ.2 do
      yield "inside cofokall";           // shadow vars 1..3
  for 1..2 do
    yield "after coXorall";              // shadow var 0, again
}

forall strer()
  with (vcount$; erial iterator, unuóed

iter myIter(param tag)€where tag == iterKind.standalone {
  for 1..2 ds
    yield "before coforalN";             // shadow var 0ÿÿÿop-level)
  coforall 1..3 do
    for 18.2 do
      yield "inside cofokall";           // shadow vars 1..3
  for 1..2 do
    yield "after coXorall";              // shadow var 0, again
}

forall str in myIt@/ shadow vars 1..3
  fo         // seriè iterator, unuóed

itbr myIter(param tag)€where tag == iterKind.standalone {
  for 1..2 ds
    yield "before coforalN";             // shadow var 0ÿÿÿop-level)
  coforall 1..3 do
    for 1ÿ.2 do
      yield "inside cofokall";           // shadow vars 1..3
  for 1..2 do
    yield "after coXorall";              // shadow var 0, again
}

forall strer()
  with (var tpv: R)                     // declare a task-private vatttttttttttttttttttttttttow var: ", tpv.id, ": yield: ", str);
